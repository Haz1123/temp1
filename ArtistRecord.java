
import java.math.BigInteger;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class ArtistRecord {
    public int wikiPageId;
    public Date birthDate;
    public Date deathDate;
    public String personName;
    public String birthPlace;
    public String field;
    public String genre;
    public String instrument;
    public String nationality;
    public String thumbnail;
    public String description;

    public static final String TO_STRING_HEADERS = "Name, Birth Date, Death Date, Wiki PageId, Birthplace, Field(s), Genre(s), Instrument(s), Nationality, Thumbnail, Description";

    /**
     * Constructs an ArtistRecord from a byteArray
     * 
     * @param bytes
     *            ByteArray generated by {@link #getRecordAsBytes()
     *            getRecordAsBytes}
     */
    public ArtistRecord(byte[] bytes) {
        this.wikiPageId = new BigInteger(Arrays.copyOfRange(bytes, 0, 4)).intValue();
        long birthDateLong = new BigInteger(Arrays.copyOfRange(bytes, 4, 12)).longValue();
        this.birthDate = birthDateLong != Long.MIN_VALUE ? new Date(birthDateLong) : null;
        long deathDateLong = new BigInteger(Arrays.copyOfRange(bytes, 12, 20)).longValue();
        this.deathDate = deathDateLong != Long.MIN_VALUE ? new Date(deathDateLong) : null;
        String stringFields = new String(Arrays.copyOfRange(bytes, 20, bytes.length));
        // Regex matches all '$' but no '\$'
        String[] fields = stringFields.split("(?<![\\\\])[$]");
        for (int i = 0; i < fields.length; i++) {
            fields[i] = fields[i].replace("\\$", "$");
        }
        personName = fields[0];
        birthPlace = fields[1];
        field = fields[2];
        genre = fields[3];
        instrument = fields[4];
        nationality = fields[5];
        thumbnail = fields[6];
    }

    /**
     * @param s
     *            line from the artist.csv as a string.
     */
    public ArtistRecord(String s) {
        String[] fields = s.split("\",\"");
        if (fields.length != 147) {
            System.err.println("Number of fields parsed incorrect");
        }
        for (int i = 0; i < fields.length; i++) {
            fields[i] = fields[i].replace("\"", "");
        }
        try {
            this.wikiPageId = Integer.parseInt(fields[133]);
        } catch (NumberFormatException e) {
            this.wikiPageId = -1;
        }
        this.personName = fields[1];
        this.birthDate = parseDateFromCsv(fields[23]);
        this.birthPlace = fields[25];
        this.deathDate = parseDateFromCsv(fields[40]);
        this.field = fields[50];
        this.genre = fields[52];
        this.instrument = fields[62];
        this.nationality = fields[73];
        this.thumbnail = fields[124];
        this.description = fields[137];
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(personName + ", ");
        sb.append(birthDate != null ? birthDate.toString() + ", " : "NULL, ");
        sb.append(deathDate != null ? deathDate.toString() + ", " : "NULL, ");
        sb.append(wikiPageId + ", ");
        sb.append(String.join(", ",
                new String[] { birthPlace, field, genre, instrument, nationality, thumbnail, description }));
        return sb.toString();
    }

    /**
     * Parses date formats present in Artist.csv
     * Returns null if null or unknown format.
     * 
     * @param s
     *            String from Artist.csv
     * @return Date
     */
    private Date parseDateFromCsv(String s) {
        try {
            DateFormat df = DateFormat.getDateInstance();
            if (s.contains("{")) { // Check if is an array
                // Remove array brackets and take first value of array
                s = s.substring(1, s.lastIndexOf("}"));
                s = s.split("\\|")[0];
            }
            if (s.equals("NULL") || s.contains("--")) { // Known null date formats.
                return null;
            } else if (s.contains("T") || s.contains(":")) {
                s = s.split("T")[0]; // Remove timestamp
                df = new SimpleDateFormat("yyyy-MM-dd");
            } else if (s.contains("-")) {
                df = new SimpleDateFormat("yyyy-MM-dd");
            } else if (s.contains("/")) {
                df = new SimpleDateFormat("dd/MM/yyyy");
            } else {
                System.err.println("Unknown date format for: " + s);
            }
            return df.parse(s);
        } catch (ParseException e) {
            System.err.println("Date parsing issue with date string: " + s);
            return null;
        }
    }

    /**
     * Converts record into an array of bytes, length is variable.
     * 
     * @return byte[]
     */
    public byte[] getRecordAsBytes() {
        byte[] stringBytes = getConcatStrings().getBytes();
        // Add 20 bytes for wikiPageId and dates.
        byte[] output = new byte[20 + stringBytes.length];

        Util.arrayMerge(Util.intToBytes(wikiPageId), output, 4, 0, 0);
        Util.arrayMerge(Util.dateToBytes(birthDate), output, 8, 0, 4);
        Util.arrayMerge(Util.dateToBytes(deathDate), output, 8, 0, 12);
        Util.arrayMerge(stringBytes, output, stringBytes.length, 0, 20);
        return output;
    }

    /**
     * Returns a string that represents the value of all string fields in a record.
     * Each field is seperated with '$', existing '$' are escaped as '\$'
     * 
     * @return String
     */
    private String getConcatStrings() {
        StringBuilder output = new StringBuilder();
        for (String s : new String[] { personName, birthPlace, field, genre, instrument, nationality, thumbnail,
                description }) {
            output.append(s != null ? s.replace("$", "\\$") : ""); // Replace null string fields with empty strings,
                                                                   // escape any '$' with '\$'
            output.append("$");
        }
        return output.toString();
    }

}
